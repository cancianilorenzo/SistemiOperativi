#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#include <errno.h>
#include <sys/wait.h>

#define MAX_CHD 5 //Max children allowed
#define MAX_CMD 20 //Max length of the commands. 
#define MAX_MSG 50 //Max length of the message

int extern errno; //Errno external variable
pthread_t t_id; //Id of the thread that will be created
int signalNumber; //Received signal number
int fd[MAX_CHD][2]; //Pipes for each child
int currentChild = 0; //Current number of active children
FILE * logFile; //Log file pointer

pid_t children[MAX_CHD]; //pid for each children
char msg[MAX_MSG]; // msg to be sent to the children
char bufferCommand[MAX_CMD] = {0}; // buffer to hold the input strings

//Handler for the thread. The thread will output on the logFile
void * threadHandler(void * param){
    fprintf(logFile,"\033[0;31m[THREAD] I'm a new thread generated by signal %d\n",*(int *)param);
    fprintf(logFile,"[THREAD] Sending message to children\n");
    
    //Send a message to each child using the pipe
    for(int i = 0; i<currentChild; i++){
        sprintf(msg,"To Child %d PID %d: %s",i,children[i],bufferCommand);
        write(fd[i][1],msg,strlen(msg));
        
        //Close the pipe
        close(fd[i][1]); 
    }
    //Reset child counter --> the children will terminate after receiving the msg
    currentChild=0;

    fprintf(logFile,"[THREAD] children reset\n"); 
    fprintf(logFile,"[THREAD] Terminating thread\n");
}

//Signal handler
pthread_attr_t attr;
void sigHandler(int signo, siginfo_t * info, void * empty){
    //Send the signal number to the thread
    signalNumber = signo;
    pthread_create(&t_id,&attr,threadHandler,(void *)&signalNumber);
}

//Handler to close the logFile upon CTRL+C
void quitHandler(int signo){
    fclose(logFile); //Close the log file
    kill(-getpid(),SIGTERM); //Terminate the hanging children
    while(wait(NULL)>0); //Wait for their termination
    printf("\n");
    exit(0);
}

int main(int argc, char ** argv){
    //Initialise sigaction
    struct sigaction sa;
    sa.sa_sigaction = sigHandler;
    sigemptyset(&sa.sa_mask);

    //Open log file
    logFile = fopen("/tmp/log.txt","w");
    
    //Initiliase attribute for threads
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);

    //Set up the various signals handlers
    sigaction(SIGUSR1,&sa,NULL);
    sigaction(SIGUSR2,&sa,NULL);
    signal(SIGINT,quitHandler);
    signal(SIGTERM, SIG_IGN); //Prevent quitHandler from terminating the main process abruptly


    printf("\033[0;32m[MAIN] my id is %d \033[0;37m\n",getpid());

    char command[MAX_CMD]; //temporary buffer for input
    int r, intCmd;
    
    while(1){
        r = read(STDIN_FILENO, command, MAX_CMD-1); //Read from stdinput
        
        //If signal generated then the read is interrupted
        if(r < 0 || errno == EINTR){
            perror("Read interrupted by interrupt");
            //Reset errno and continue
            errno = 0;
            continue;
        }
        command[r-1] = 0; //Terminate string
        
        //Convert command to int
        intCmd = atoi(command);
        if(intCmd > 0){ //It is an integer > 0
            if(currentChild < MAX_CHD){ //It can create another child
                pipe(fd[currentChild]); //Create pipe for the new child
                children[currentChild] = fork(); //Create new child saving its pid
                if(children[currentChild]  == 0){ //Child
                    close(fd[currentChild][1]); //Close writing side of pipe
                    break; //Exit from the while
                }
                close(fd[currentChild][0]); //close the read side of the pipe
                currentChild++; //Increase the number of children
            }else{
                fprintf(stderr,"\033[0;32m[MAIN] Too many children. Send msg to free them \033[0;37m\n");
            }
        }else{ //If it was not an integer it is a message
            strncpy(bufferCommand,command,r); //Save the message to the buffer
            fprintf(stderr,"\033[0;32m[MAIN] Msg saved \033[0;37m\n");
        }
    }
    // Only child
    signal(SIGTERM, SIG_DFL); //Reset the sighandler to its default handler
    printf("\033[0;33m[CHD] I'm a new child with id %d, and I'm waiting for msg from my father\033[0;37m\n",getpid());
    read(fd[currentChild][0],&msg,MAX_MSG); //Read the message from the pipe
    printf("\033[0;33m[CHD] I received the following message: %s \033[0;37m\n",msg);
    close(fd[currentChild][0]); //Close read side of pipe.
    
}